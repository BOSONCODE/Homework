前两周很顺利, 算法和代码理解只用了三天，剩下的都是在自己研究背后的东

西，学到了不少。
这两周要开新算法也就是ACL算法，这个东西浪费了我不少时间，因为代码找错

了，产品中使用的并不是最基本的ACL算法，而是用hash改进过，还有ACL ip技

术研究部的算法，和AR(也就是我一开始接触的是完全不一样的), 当然这都是

后来才知道的。
肯定当时是文档，论文啥的。之前的tree bitmap那个算法主要是应用在路由查

找层，目的是将source ip转发到destination ip。这次的ACL算法是进行规则

的匹配过滤。这里的规则包含了source ip | destination ip| action
action包括permitted, denied。具体算法就不说了，同样也是运用了分块和

位运算，主要是在面对代码的时候还是花了好一些时间的。算法的api实现，算

法的高级一层的调用，代码分层比较明显，所以需要顺藤摸瓜，而文件又有很

多，所以在查找文件的时候还是花了不少时间的。

公司具体工作内容不太方便透露，那就只能说说我之间干了啥，学到了啥。在

ACL的那章节中有一个算法叫做FC(Fractional Cascading)很神奇，一个来自

于Computation Geometry的优化技巧, 一个简单的应用场景是:
给定n个sorted lists 和一个target value,目的是找出n个lists中分别大于

等于target value的第一个数的下标，如果没有则返回lists的size(设为m

吧).
很简单稳定的做法就是 做n次二分, 那么复杂度就是 O(nlogm),已经很优秀了

。但是这是在FC算法出现之前。能不能把这个log去掉，因为当m的数量相当巨

大的时候这个logm所带来的常数还是不小的。
FC算法通过构建一个M数组来达到这个目的，M数组里每一个元素存了一个二元

组pair(pos, next)pos表示在当期list里的下标，next表示下一个第一个大于

等于target value的下标，然后这样查找的时候只需要沿着next跳就行了，只

有第一次查找M的时候需要二分,所以复杂度就是O(n + logm) 不过这样空间复

杂度也增高，但是可以证明空间复杂度小于2nm, 具体的证明我在组内

presentation的时候证明过，大概方法就是利用公比为1/2的级数, 最后会保证

趋向于2。
另外就是学习了一些makefile, shell啥的，不过实际我也没用到，也就是简单

地看了下，万一以后用到呢。
