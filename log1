7.6
昨天刚刚期末考完，今天就要入职，有点期待，有点兴奋，到了公司之后就好

多了，感觉也就这样了，不过毕竟人生第一份正式的实习。
第一个星期主要是学习公司的内部学习文档，大概是关于编码安全规范之类的

，公司给我申请linux服务器和桌面云等等，有点慢。另外就是开始学习导师分

配的任务tree bitmap路由转发层算法的学习，然后就是在组内进行展示，具体

细节就不说了(保密协议签着呢)。我被分配到的任务就是研究学习路由转发层

的算法，然后向导师组内展示。

第二个星期就开始做展示了，这个算法还是蛮简单的，主要就是bitmap优化搜

索树。但是学习到了很多东西。主要是神奇的位运算和一些linux内核的东西。 
位运算有一本书叫做<<hacker's delight>>,这书涵盖了很多神奇的运算，应该

是世界上最快的了。对于产品代码在此基础上还有一些分块等等的运用，还是

很漂亮的。
举个例子求解一个无符号32位十进制数二进制中1的个数:
比如6 =(0...0110)_2 => 2, 7=(0...0111)_2 => 3
uint32_t __builtin_popcount(uint32_t x){
	x = ((x >> 1) & 0x55555555)) + (x & 0x55555555);
	x = ((x >> 2) & 0x33333333)) + (x & 0x33333333);
	x = ((x >> 4) & 0x0F0F0F0F)) + (x & 0x0F0F0F0F);
	x = ((x >> 8) & 0x00FF00FF)) + (x & 0x00FF00FF);
	x = ((x >> 16) & 0x0000FFFF) + (x & 0x0000FFFF);
	return x;
}
当然8bits, 16bits, 64bits依次类推，不过这个还不是最快的。
简单说下原理吧
举个简单的例子:
1 2 3 4 5 6 7 8
现在要讲这一组数字给翻转过来，这里利用的算法的核心步骤就是，第一次两

个为一组，也就是(1 2), (3 4), (5 6), (7 8)
然后翻转(2 1)(4 3)(6 5)(8 7)
接下来就是四个数为一组((2 1) (4 3))((6 5) (8 7))
翻转过来就是(4 3 2 1)(8 7 6 5)
再接下来就是八个数为一组翻转过来就是(8 7 6 5 4 3 2 1)
end
这是对于翻转一个二进制数所采用的算法
uint32_t reverse(uint32_t x){
	x = ((x & 0x55555555) << 1) | ((x & 0xAAAAAAAA) >> 1);
	x = ((x & 0x33333333) << 2) | ((x & 0xCCCCCCCC) >> 2);
	x = ((x & 0x0F0F0F0F) << 4) | ((x & 0xF0F0F0F0) >> 4);
	x = ((x & 0x00FF00FF) << 8) | ((x & 0xFF00FF00) >> 8);
	x = ((x & 0x0000FFFF) << 16)| ((x & 0xFFFF0000) >> 16);
	return x;
}
用同样的思路, 利用二进制加法进位的性质先是两个为一组，然后四个为一组

，来进行计算。比如 (x >> 1)&0x55555555就是计算奇数bit上1的个数+(x & 

0x55555555)就是计算偶数bit上1的个数。这个所谓的个数就是最终的和x的相

邻两个bit表示的就是对应组内1的个数

另外就是linux内核, 主要就是doubly linked lists 核心就是两个宏, 

container_of 和 offsetof。真的是神奇, 不得不佩服那些geeks。
在实习期间能够学习到这些还是很让人兴奋的。
